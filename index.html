<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VC Jump Game Parody</title>
  <style>
    body { margin: 0; overflow: hidden; background: #87CEEB; }
    canvas { display: block; }
    #scoreboard {
      position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
      color: #000; font: 20px monospace; text-shadow: 1px 1px #fff;
    }
    #message {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      color: #000; font: 24px monospace; text-align: center; white-space: pre;
    }
  </style>
</head>
<body>
  <div id="scoreboard">Score: 0&nbsp;&nbsp;Best: 0</div>
  <div id="message">Press Space or Tap to Start</div>
  <canvas id="game"></canvas>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let W, H;
    let groundY;

    // Resize
    function resize() {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
      groundY = H / 2;
    }
    window.addEventListener('resize', resize);
    resize();

    // Assets
    const spriteImg = new Image(); spriteImg.src = 'vc-run.png'; // 3-frame running VC sprite sheet
    const groundImg = new Image(); groundImg.src = 'ground.png'; // pixel-art ground tile
    const obstacleImg = new Image(); obstacleImg.src = 'believe.png'; // green 'B' logo obstacle
    const cloudImg = new Image(); cloudImg.src = 'cloud1.png'; // stylized white pixel-art cloud

    // Game state
    const player = { x: 100, y: 0, w: 50, h: 75, frame: 0, frameTimer: 0, vy: 0, gravity: 0.6, jump: -15 };
    let gameStarted = false, gameOver = false;
    let score = 0, best = localStorage.getItem('vcBest') || 0;
    const obstacles = [];
    const quotes = [];
    const obstacleSpeedBase = 6;
    let speed = obstacleSpeedBase, spawnTimer = 0, quoteTimer = 0;
    const vcQuotes = [
      'Raise fast, fail faster.',
      'Your burn rate is my vibe rate.',
      'Pivot or perish.',
      'Terms: 0% equity, 200% ghosting.',
      'Disrupt the disruptors.',
      'Build in stealth mode.',
      'Scale or sail away.',
      'Remember: traction > strategy.'
    ];

    // Parallax cloud layer
    const clouds = [];
    function initClouds() {
      clouds.length = 0;
      for (let i = 0; i < 5; i++) {
        clouds.push({ x: Math.random() * W, y: Math.random() * groundY / 2, speed: 1 + Math.random() });
      }
    }

    // Spawn functions
    function spawnObstacle() {
      const h = 30 + Math.random() * 50;
      obstacles.push({ x: W, y: groundY - h, w: h, h: h, passed: false });
    }
    function spawnQuote() {
      if (score % 20 !== 0) return;
      const text = vcQuotes[Math.floor(Math.random() * vcQuotes.length)];
      quotes.push({ x: W, y: groundY + 20 + Math.random() * 30, text: text, size: 16 + Math.random() * 8, collected: false });
    }

    // Reset game
    function reset() {
      obstacles.length = 0;
      quotes.length = 0;
      player.y = groundY - player.h;
      player.vy = 0;
      score = 0;
      speed = obstacleSpeedBase;
      gameStarted = false;
      gameOver = false;
      document.getElementById('scoreboard').textContent = `Score: ${score}  Best: ${best}`;
      document.getElementById('message').textContent = 'Press Space or Tap to Start';
      initClouds();
      draw();
    }

    // Draw initial frame
    function draw() {
      ctx.clearRect(0, 0, W, H);
      // Background cycle
      const cycle = Math.floor(score / 50) % 2;
      document.body.style.background = cycle ? '#1a1a2e' : '#87CEEB';
      // Draw clouds
      clouds.forEach(c => {
        c.x -= c.speed;
        if (c.x < -200) c.x = W;
        ctx.drawImage(cloudImg, c.x, c.y, 200, 100);
      });
      // Draw ground
      const pat = ctx.createPattern(groundImg, 'repeat-x');
      ctx.fillStyle = pat;
      ctx.fillRect(0, groundY, W, 40);
      // Draw obstacles
      obstacles.forEach(o => {
        ctx.drawImage(obstacleImg, o.x, o.y, o.w, o.h);
      });
      // Draw quotes above ground
      quotes.forEach(q => {
        ctx.fillStyle = '#fff';
        ctx.font = `${q.size}px monospace`;
        ctx.fillText(q.text, q.x, q.y);
      });
      // Draw player frame or fallback
      if (spriteImg.complete && spriteImg.naturalWidth) {
        ctx.drawImage(spriteImg, player.frame * player.w, 0, player.w, player.h, player.x, player.y, player.w, player.h);
      } else {
        ctx.fillStyle = '#0f0';
        ctx.fillRect(player.x, player.y, player.w, player.h);
      }
    }

    // Game update loop
    function update() {
      if (!gameStarted || gameOver) return;
      // Spawn logic
      spawnTimer++;
      if (spawnTimer > 90) { spawnTimer = 0; spawnObstacle(); }
      quoteTimer++;
      if (quoteTimer > 300) { quoteTimer = 0; spawnQuote(); }
      // Apply physics
      player.vy += player.gravity;
      player.y += player.vy;
      if (player.y + player.h > groundY) {
        player.y = groundY - player.h;
        player.vy = 0;
      }
      // Move obstacles & handle score
      obstacles.forEach((o, i) => {
        o.x -= speed;
        if (!o.passed && o.x + o.w < player.x) {
          o.passed = true;
          score++;
          if (score > best) { best = score; localStorage.setItem('vcBest', best); }
          document.getElementById('scoreboard').textContent = `Score: ${score}  Best: ${best}`;
          speed = obstacleSpeedBase + score * 0.02;
        }
        // Collision detection
        if (player.x < o.x + o.w && player.x + player.w > o.x && player.y < o.y + o.h && player.y + player.h > o.y) {
          gameOver = true;
          document.getElementById('message').textContent = `RIP VC\nScore: ${score}  Best: ${best}\nPress Space or Tap`;
        }
        if (o.x + o.w < 0) obstacles.splice(i, 1);
      });
      // Move quotes
      quotes.forEach((q, i) => {
        q.x -= speed * 0.5;
        if (q.x + ctx.measureText(q.text).width < 0) quotes.splice(i, 1);
      });
      // Animate player frame
      player.frameTimer++;
      if (player.frameTimer > 5) {
        player.frame = (player.frame + 1) % 3;
        player.frameTimer = 0;
      }
      // Redraw everything
      draw();
      requestAnimationFrame(update);
    }

    // Jump handler
    function jump() {
      if (gameStarted && !gameOver && player.vy === 0) {
        player.vy = player.jump;
      }
    }
    // Controls
    window.addEventListener('keydown', e => {
      if (e.code === 'Space') {
        if (!gameStarted) { gameStarted = true; document.getElementById('message').textContent = ''; update(); }
        else if (gameOver) reset();
        else jump();
      }
    });
    canvas.addEventListener('touchstart', () => {
      if (!gameStarted) { gameStarted = true; document.getElementById('message').textContent = ''; update(); }
      else if (gameOver) reset();
      else jump();
    });

    // Initialize
    reset();
  </script>
</body>
</html>
