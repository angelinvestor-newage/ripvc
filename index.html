<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>VC Suitcase Jump Game</title>
  <style>
    body { margin: 0; padding: 0; background: #0d0d0d; overflow: hidden; font-family: monospace; }
    canvas { display: block; background: #222; }
    #score { position: absolute; top: 10px; left: 10px; color: #0f0; font-size: 20px; }
    #message { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
               color: #f00; font-size: 24px; white-space: pre; text-align: center; }
    #quotePopup { position: absolute; top: 60%; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.8); color: #0ff; font-size: 18px;
      padding: 8px 16px; border: 2px solid #0f0; display: none; }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <div id="message">Press Space to Start</div>
  <div id="quotePopup"></div>
  <canvas id="game"></canvas>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let groundY;
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      groundY = canvas.height / 2;
      drawInitial();
    }
    window.addEventListener('resize', resize);
    resize();

    // Load VC sprite sheet
    const spriteImg = new Image(); spriteImg.src = 'vc-run.png';

    // Player properties
    const player = { x: 50, y: 0, w: 50, h: 75, vy: 0, gravity: 0.6, jumpForce: -15, frame: 0, frameTimer: 0, frameCount: 3 };

    // Obstacles and quotes
    const obstacles = []; let spawnTimer = 0; const obstacleSpeed = 6;
    const quotes = []; let quoteTimer = 0;
    const vcQuotes = [
      'Raise fast, fail faster.', 'Your burn rate is my vibe rate.',
      'Pivot or perish.', 'Terms: 0% equity, 200% ghosting.',
      'Disrupt the disruptors.', 'Build in stealth mode.',
      'Scale or sail away.', 'Remember: traction > strategy.'
    ];

    // UI elements
    const scoreDiv = document.getElementById('score');
    const messageDiv = document.getElementById('message');
    const quotePopup = document.getElementById('quotePopup');

    let score = 0, gameStarted = false, gameOver = false;

    function drawPlayer() {
      // Fallback: always draw green box
      ctx.fillStyle = '#0f0';
      ctx.fillRect(player.x, player.y, player.w, player.h);
      // Overlay sprite if loaded
      if (spriteImg.complete && spriteImg.naturalWidth) {
        const sw = spriteImg.naturalWidth / player.frameCount;
        const sh = spriteImg.naturalHeight;
        ctx.drawImage(
          spriteImg,
          player.frame * sw, 0,
          sw, sh,
          player.x, player.y,
          player.w, player.h
        );
      }
    }

    function drawInitial() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#555'; ctx.fillRect(0, groundY, canvas.width, 5);
      player.x = 50; player.y = groundY - player.h;
      player.frame = 0; player.frameTimer = 0;
      drawPlayer();
    }

    function spawnObstacle() {
      const size = 30 + Math.random() * 50;
      obstacles.push({ x: canvas.width, y: groundY - size, size, passed: false });
    }
    function spawnQuote() {
      const t = vcQuotes[Math.floor(Math.random() * vcQuotes.length)];
      quotes.push({ x: canvas.width, y: groundY - player.h - 80, text: t, size: 18, collected: false });
    }

    function resetGame() {
      obstacles.length = 0; quotes.length = 0;
      score = 0; gameOver = false; gameStarted = false;
      scoreDiv.textContent = 'Score: 0';
      messageDiv.textContent = 'Press Space to Start';
      drawInitial();
    }

    function update() {
      if (!gameStarted || gameOver) return;
      spawnTimer++; if (spawnTimer > 90) { spawnTimer = 0; spawnObstacle(); }
      quoteTimer++; if (quoteTimer > 300) { quoteTimer = 0; spawnQuote(); }
      // Physics
      player.vy += player.gravity; player.y += player.vy;
      if (player.y + player.h > groundY) { player.y = groundY - player.h; player.vy = 0; }
      // Animate sprite
      if (spriteImg.complete && spriteImg.naturalWidth) {
        player.frameTimer++;
        if (player.frameTimer > 6) { player.frame = (player.frame + 1) % player.frameCount; player.frameTimer = 0; }
      }
      // Clear & draw
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#555'; ctx.fillRect(0, groundY, canvas.width, 5);
      drawPlayer();
      // Draw obstacles
      obstacles.forEach((obs, i) => {
        obs.x -= obstacleSpeed;
        ctx.fillStyle = '#f00'; ctx.font = obs.size + 'px monospace'; ctx.fillText('B', obs.x, obs.y + obs.size);
        if (!obs.passed && obs.x + obs.size < player.x) { obs.passed = true; score++; scoreDiv.textContent = 'Score: ' + score; }
        if (player.x < obs.x + obs.size && player.x + player.w > obs.x && player.y < obs.y + obs.size && player.y + player.h > obs.y) {
          gameOver = true; messageDiv.textContent = 'RIP VC\nFinal Score: ' + score + '\nPress Space to Restart';
        }
        if (obs.x + obs.size < 0) obstacles.splice(i, 1);
      });
      // Draw quotes
      quotes.forEach((q, i) => {
        q.x -= obstacleSpeed * 0.8;
        ctx.fillStyle = '#0ff'; ctx.font = q.size + 'px monospace'; ctx.fillText(q.text, q.x, q.y);
        if (q.x + ctx.measureText(q.text).width < player.x && !q.collected) { q.collected = true; quotePopup.textContent = q.text; quotePopup.style.display = 'block'; setTimeout(() => quotePopup.style.display = 'none', 2000); }
        if (q.x + ctx.measureText(q.text).width < 0) quotes.splice(i, 1);
      });
      requestAnimationFrame(update);
    }

    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        if (!gameStarted) { gameStarted = true; messageDiv.textContent = ''; update(); }
        else if (gameOver) resetGame();
        else if (player.vy === 0) player.vy = player.jumpForce;
      }
    });

    resetGame();
  </script>
</body>
</html>
