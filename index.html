<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>VC Suitcase Jump Game + Quotes</title>
  <style>
    body { margin: 0; overflow: hidden; background: #0d0d0d; }
    canvas { display: block; background: #222; }
    #score { position: absolute; top: 10px; left: 10px; color: #0f0; font: 20px monospace; }
    #message { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
               color: #f00; font: 36px monospace; white-space: pre; text-align: center; }
    #quotePopup {
      position: absolute; top: 60%; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.8); color: #fff; font: 18px monospace;
      padding: 10px 20px; border: 2px solid #0f0; border-radius: 4px;
      display: none; max-width: 80%; text-align: center;
    }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <div id="message"></div>
  <div id="quotePopup"></div>
  <canvas id="game"></canvas>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let groundY;
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      groundY = canvas.height / 2;
      // Center the VC horizontally
      player.x = Math.floor(canvas.width / 2 - player.w / 2);
    }
    window.addEventListener('resize', resize);

    // Player sprite
    const playerImg = new Image();
    playerImg.src = 'vc-sprite.png';
    // Obstacle image
    const obstacleImg = new Image();
    obstacleImg.src = 'believe.jpg';

    // Player properties
    const player = { x: 0, y: 0, w: 40, h: 60, vy: 0, gravity: 0.6, jumpForce: -15 };

    // Game state
    const obstacles = [];
    const quotes = [];
    const vcQuotes = [
      'Raise fast, fail faster.',
      'Your burn rate is my vibe rate.',
      'Pivot or perish.',
      'Terms: 0% equity, 200% ghosting.',
      'Disrupt the disruptors.',
      'Build in stealth mode.',
      'Scale or sail away.',
      'Remember: traction > strategy.'
    ];
    const obstacleSpeed = 6;
    let spawnTimer = 0, quoteTimer = 0;
    let score = 0, gameOver = false;

    // UI elements
    const scoreDiv = document.getElementById('score');
    const messageDiv = document.getElementById('message');
    const quotePopup = document.getElementById('quotePopup');

    function spawnObstacle() {
      const size = 40 + Math.random() * 60;
      obstacles.push({ x: canvas.width, y: groundY - size, size, passed: false });
    }
    function spawnQuote() {
      const text = vcQuotes[Math.floor(Math.random() * vcQuotes.length)];
      const size = 16 + Math.random() * 8;
      // Display below the ground line
      const y = groundY + size + 10;
      quotes.push({ x: canvas.width, y, text, size, collected: false });
    }

    function resetGame() {
      obstacles.length = 0;
      quotes.length = 0;
      player.y = groundY - player.h;
      player.vy = 0;
      score = 0;
      gameOver = false;
      messageDiv.textContent = '';
      scoreDiv.textContent = 'Score: 0';
      resize();
    }

    function getRandomColor() {
      const colors = ['#00FFFF','#FF00FF','#FFFF00','#00FF00','#FFFFFF','#FFA500','#FF0000','#0000FF','#FF69B4'];
      return colors[Math.floor(Math.random() * colors.length)];
    }

    function update() {
      if (gameOver) return;
      spawnTimer++;
      quoteTimer++;
      if (spawnTimer > 90) { spawnTimer = 0; spawnObstacle(); }
      if (quoteTimer > 300) { quoteTimer = 0; spawnQuote(); }

      // Physics
      player.vy += player.gravity;
      player.y += player.vy;
      if (player.y + player.h > groundY) { player.y = groundY - player.h; player.vy = 0; }

      // Render
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // Ground line
      ctx.fillStyle = '#555';
      ctx.fillRect(0, groundY, canvas.width, 4);

      // Draw player
      if (playerImg.complete) {
        ctx.drawImage(playerImg, player.x, player.y, player.w, player.h);
      }

      // Obstacles
      obstacles.forEach((obs, i) => {
        obs.x -= obstacleSpeed;
        if (obstacleImg.complete) {
          ctx.drawImage(obstacleImg, obs.x, obs.y, obs.size, obs.size);
        }
        if (!obs.passed && obs.x + obs.size < player.x) {
          obs.passed = true;
          score++;
          scoreDiv.textContent = 'Score: ' + score;
        }
        // Collision
        if (player.x < obs.x + obs.size && player.x + player.w > obs.x &&
            player.y < obs.y + obs.size && player.y + player.h > obs.y) {
          gameOver = true;
          messageDiv.textContent = `RIP VC\nFinal Score: ${score}\nPress Space to Restart`;
        }
        if (obs.x + obs.size < 0) obstacles.splice(i,1);
      });

      // Quotes below line
      quotes.forEach((q, i) => {
        q.x -= obstacleSpeed * 0.8;
        ctx.fillStyle = '#0ff';
        ctx.font = q.size + 'px monospace';
        ctx.fillText(q.text, q.x, q.y);
        if (!q.collected && player.x < q.x + ctx.measureText(q.text).width &&
            player.x + player.w > q.x && player.y < q.y && player.y + player.h > q.y - q.size) {
          q.collected = true;
          quotePopup.textContent = q.text;
          quotePopup.style.display = 'block';
          setTimeout(() => quotePopup.style.display = 'none', 2000);
        }
        if (q.x + ctx.measureText(q.text).width < 0 || q.collected) quotes.splice(i,1);
      });

      requestAnimationFrame(update);
    }

    window.addEventListener('keydown', e => {
      if (e.code === 'Space') {
        if (gameOver) { resetGame(); requestAnimationFrame(update); }
        else if (player.vy === 0) { player.vy = player.jumpForce; }
      }
    });

    resetGame();
    update();
  </script>
</body>
</html>
