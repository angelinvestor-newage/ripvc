<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>VC Suitcase Jump Game</title>
  <style>
    body { margin: 0; padding: 0; background: #0d0d0d; overflow: hidden; font-family: monospace; }
    canvas { display: block; background: #222; image-rendering: pixelated; }
    #score { position: absolute; top: 10px; left: 10px; color: #0f0; font-size: 20px; }
    #message { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
               color: #f00; font-size: 24px; white-space: pre; text-align: center; }
    #quotePopup { position: absolute; top: 60%; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.8); color: #0ff; font-size: 18px; padding: 8px 16px; border: 2px solid #0f0; display: none; }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <div id="message">Press Space to Start</div>
  <div id="quotePopup"></div>
  <canvas id="game"></canvas>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;

    let W, H, groundY;
    function resize() {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
      groundY = H / 2;
    }
    window.addEventListener('resize', resize);
    resize();

    // Load transparent VC sprite sheet
    const sprite = new Image();
    sprite.src = 'din.png'; // must have a transparent background

    // Player state (2x size)
    const player = {
      x: 50,
      y: groundY - 150,
      w: 100,
      h: 150,
      vy: 0,
      gravity: 0.6,
      jumpForce: -20,
      frame: 0,
      frameTimer: 0,
      frameCount: 3
    };

    // Game arrays
    const obstacles = [];
    let spawnTimer = 0;
    const obstacleSpeed = 6;
    const quotes = [];
    let quoteTimer = 0;
    const vcQuotes = [
      'Raise fast, fail faster.', 'Your burn rate is my vibe rate.',
      'Pivot or perish.', 'Terms: 0% equity, 200% ghosting.',
      'Disrupt the disruptors.', 'Build in stealth mode.',
      'Scale or sail away.', 'Remember: traction > strategy.'
    ];

    // UI
    const scoreDiv   = document.getElementById('score');
    const messageDiv = document.getElementById('message');
    const quotePopup = document.getElementById('quotePopup');

    let score = 0;
    let gameStarted = false;
    let gameOver = false;

    // Draw player: fallback or sprite
    function drawPlayer() {
      if (sprite.complete && sprite.naturalWidth) {
        const sw = sprite.naturalWidth / player.frameCount;
        const sh = sprite.naturalHeight;
        ctx.drawImage(
          sprite,
          player.frame * sw, 0, sw, sh,
          player.x, player.y, player.w, player.h
        );
      } else {
        ctx.fillStyle = '#0f0';
        ctx.fillRect(player.x, player.y, player.w, player.h);
      }
    }

    // Main loop
    function loop() {
      // clear and draw ground
      ctx.clearRect(0,0,W,H);
      ctx.fillStyle = '#555';
      ctx.fillRect(0, groundY, W, 5);

      // draw obstacles
      ctx.fillStyle = '#f00';
      obstacles.forEach(o => {
        o.x -= obstacleSpeed;
        ctx.font = o.size + 'px monospace';
        ctx.fillText('B', o.x, o.y + o.size);
      });

      // draw quotes
      ctx.fillStyle = '#0ff';
      quotes.forEach(q => {
        q.x -= obstacleSpeed * 0.8;
        ctx.font = q.size + 'px monospace';
        ctx.fillText(q.text, q.x, q.y);
      });

      // update & draw player if game started
      if (gameStarted && !gameOver) {
        // physics
        player.vy += player.gravity;
        player.y += player.vy;
        if (player.y + player.h > groundY) {
          player.y = groundY - player.h;
          player.vy = 0;
        }
        // sprite anim
        if (sprite.complete) {
          player.frameTimer++;
          if (player.frameTimer > 6) {
            player.frameTimer = 0;
            player.frame = (player.frame + 1) % player.frameCount;
          }
        }
        drawPlayer();
      } else {
        // initial or game over, show player at start
        player.y = groundY - player.h;
        player.frame = 0;
        drawPlayer();
      }

      requestAnimationFrame(loop);
    }
    loop();

    // Input
    window.addEventListener('keydown', e => {
      if (e.code === 'Space') {
        if (!gameStarted) {
          gameStarted = true;
          messageDiv.style.display = 'none';
        } else if (gameOver) {
          // reset state
          obstacles.length = 0;
          quotes.length = 0;
          score = 0; gameOver = false;
          scoreDiv.textContent = 'Score: 0';
          messageDiv.textContent = 'Press Space to Start';
          messageDiv.style.display = '';
        } else if (player.vy === 0) {
          player.vy = player.jumpForce;
        }
      }
    });

    // Spawn logic separately
    setInterval(() => {
      if (gameStarted && !gameOver) {
        spawnTimer++;
        if (spawnTimer > 90) {
          spawnTimer = 0;
          const size = 30 + Math.random() * 50;
          obstacles.push({ x: W, y: groundY - size, size, passed: false });
        }
        quoteTimer++;
        if (quoteTimer > 300) {
          quoteTimer = 0;
          const txt = vcQuotes[Math.floor(Math.random()*vcQuotes.length)];
          quotes.push({ x: W, y: groundY - player.h - 80, text: txt, size: 18, collected: false });
        }
      }
    }, 16);

  </script>
</body>
</html>
