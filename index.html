<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>VC Jump Game Parody</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
    #scoreboard {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: #fff;
      font: 20px monospace;
    }
    #message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font: 24px monospace;
      text-align: center;
      white-space: pre;
    }
  </style>
</head>
<body>
  <div id="scoreboard">Score: 0  Best: 0</div>
  <div id="message">Press Space or Tap to Start</div>
  <canvas id="game"></canvas>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let W, H, groundY;

    function resize() {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
      groundY = H / 2;
      drawInitial();
    }
    window.addEventListener('resize', resize);
    resize();

    // Assets
    const spriteImg = new Image(); spriteImg.src = 'vc-run.png'; // 3-frame running VC sprite sheet
    const obstacleImg = new Image(); obstacleImg.src = 'believe.png'; // green 'B' logo obstacle
    const cloudImg = new Image(); cloudImg.src = 'cloud1.png'; // stylized white pixel-art cloud

    // Game state
    const player = { x: 0, y: 0, w: 50, h: 75, frame: 0, frameTimer: 0, vy: 0, gravity: 0.6, jump: -15 };
    let gameStarted = false, gameOver = false;
    let score = 0, best = localStorage.getItem('vcBest') || 0;
    const obstacles = [];
    const quotes = [];
    const obstacleSpeedBase = 6;
    let speed = obstacleSpeedBase, spawnTimer = 0, quoteTimer = 0;
    const vcQuotes = [
      'Raise fast, fail faster.',
      'Your burn rate is my vibe rate.',
      'Pivot or perish.',
      'Terms: 0% equity, 200% ghosting.',
      'Disrupt the disruptors.',
      'Build in stealth mode.',
      'Scale or sail away.',
      'Remember: traction > strategy.'
    ];

    // Clouds
    const clouds = [];
    function initClouds() {
      clouds.length = 0;
      for (let i = 0; i < 5; i++) {
        clouds.push({ x: Math.random() * W, y: Math.random() * (groundY / 3), speed: 0.5 + Math.random() * 0.5 });
      }
    }
    initClouds();

    // Spawn
    function spawnObstacle() {
      const h = 30 + Math.random() * 50;
      obstacles.push({ x: W, y: groundY - h, w: h, h: h, passed: false });
    }
    function spawnQuote() {
      if (score % 20 !== 0) return;
      const text = vcQuotes[Math.floor(Math.random() * vcQuotes.length)];
      quotes.push({ x: W, y: groundY + 20 + Math.random() * 10, text, size: 16 + Math.random() * 4, collected: false });
    }

    // Reset
    function reset() {
      obstacles.length = 0;
      quotes.length = 0;
      player.x = Math.floor(W/2 - player.w/2);
      player.y = groundY - player.h;
      player.vy = 0;
      score = 0;
      speed = obstacleSpeedBase;
      gameStarted = false;
      gameOver = false;
      document.getElementById('scoreboard').textContent = `Score: ${score}  Best: ${best}`;
      document.getElementById('message').textContent = 'Press Space or Tap to Start';
      initClouds();
      drawInitial();
    }

    // Draw initial screen
    function drawInitial() {
      ctx.clearRect(0, 0, W, H);
      // Ground full bottom
      ctx.fillStyle = '#555';
      ctx.fillRect(0, groundY, W, H - groundY);
      // Clouds small
      clouds.forEach(c => {
        ctx.drawImage(cloudImg, c.x, c.y, 80, 40);
      });
      // Player fallback
      player.x = Math.floor(W/2 - player.w/2);
      ctx.fillStyle = '#0f0';
      ctx.fillRect(player.x, player.y, player.w, player.h);
      // Overlay sprite if loaded
      if (spriteImg.complete && spriteImg.naturalWidth) {
        ctx.drawImage(spriteImg, player.frame * player.w, 0, player.w, player.h, player.x, player.y, player.w, player.h);
      }
    }

    // Update loop
    function update() {
      if (!gameStarted || gameOver) return;
      spawnTimer++; if (spawnTimer > 90) { spawnTimer = 0; spawnObstacle(); }
      quoteTimer++; if (quoteTimer > 300) { quoteTimer = 0; spawnQuote(); }

      // Physics
      player.vy += player.gravity;
      player.y += player.vy;
      if (player.y + player.h > groundY) { player.y = groundY - player.h; player.vy = 0; }

      // Clear
      ctx.clearRect(0, 0, W, H);
      // Ground
      ctx.fillStyle = '#555';
      ctx.fillRect(0, groundY, W, H - groundY);
      // Clouds
      clouds.forEach(c => { c.x -= c.speed; if (c.x < -80) c.x = W; ctx.drawImage(cloudImg, c.x, c.y, 80, 40); });

      // Obstacles
      obstacles.forEach((o, i) => {
        o.x -= speed;
        ctx.fillStyle = '#0f0';
        ctx.fillRect(o.x, o.y, o.w, o.h);
        if (!o.passed && o.x + o.w < player.x) {
          o.passed = true;
          score++;
          if (score > best) { best = score; localStorage.setItem('vcBest', best); }
          document.getElementById('scoreboard').textContent = `Score: ${score}  Best: ${best}`;
          speed = obstacleSpeedBase + score * 0.02;
        }
        if (player.x < o.x + o.w && player.x + player.w > o.x && player.y < o.y + o.h && player.y + player.h > o.y) {
          gameOver = true;
          document.getElementById('message').textContent = `RIP VC\nScore: ${score}  Best: ${best}\nPress Space or Tap`;
        }
        if (o.x + o.w < 0) obstacles.splice(i, 1);
      });

      // Quotes
      quotes.forEach((q, i) => {
        q.x -= speed * 0.5;
        ctx.fillStyle = '#fff';
        ctx.font = `${q.size}px monospace`;
        ctx.fillText(q.text, q.x, q.y);
        if (q.x + ctx.measureText(q.text).width < 0) quotes.splice(i, 1);
      });

      // Animate player
      player.frameTimer++;
      if (player.frameTimer > 5) { player.frame = (player.frame + 1) % 3; player.frameTimer = 0; }
      // Draw player
      ctx.fillStyle = '#0f0';
      ctx.fillRect(player.x, player.y, player.w, player.h);
      if (spriteImg.complete && spriteImg.naturalWidth) {
        ctx.drawImage(spriteImg, player.frame * player.w, 0, player.w, player.h, player.x, player.y, player.w, player.h);
      }

      requestAnimationFrame(update);
    }

    // Controls
    function jump() { if (gameStarted && !gameOver && player.vy === 0) { player.vy = player.jump; }}
    window.addEventListener('keydown', e => {
      if (e.code === 'Space') {
        if (!gameStarted) { gameStarted = true; document.getElementById('message').textContent = ''; update(); }
        else if (gameOver) reset();
        else jump();
      }
    });
    canvas.addEventListener('touchstart', () => {
      if (!gameStarted) { gameStarted = true; document.getElementById('message').textContent = ''; update(); }
      else if (gameOver) reset();
      else jump();
    });

    // Init
    reset();
  </script>
</body>
</html>
